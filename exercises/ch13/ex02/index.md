## f3

予想 : A,Cが即座に表示され、そのあとerrXが実行される。
回答 :

```
C
A
throw new Error("X");
```

説明 :Promiseのcatch,finallyメソッドではないため、try-catchで非同期処理の例外を捕まえられない。そのため、finally内のlogCが即座に実行され、そのあとlogA,errXが実行されて終了する。

## f4

予想 : 2秒経過後にAが出力され、そのあと１秒後にBが出力され、そのあと100が出力される。
回答 : 2秒経過後にAが出力され、そのあと１秒後にBが出力され、そのあと100が出力される。
説明 : 2つ目の .then のコールバック関数が100をreturnしているため、 3つ目の .thenで100が出力される。

## f5

予想 : wait1の引数がPromiseになっているため、そこの評価がwait2と同時に行われる。そのため、1秒後にBが出力され、その1秒後(開始から2秒後)にAが出力され、40が出力される。
回答 : 同上
説明 : 2つめの.thenは関数が渡っているわけではないので、評価されるが次のthenには元の値をそのまま渡す事になる。よって40が出力される。

## f6

予想 : 1秒後にAが出力され、そのあと１秒と２秒の計測が始まる。結果としてA出力後１秒後にBが、その１秒後にCが出力される。
回答 : 同上
説明 :同じPromiseに対して複数thenを呼び出しても、それぞれ独立したチェーンとなる。

## f7

予想 : 開始から1秒後にAが出力、開始から2秒後にBとCが出力される。
回答 : 同上
説明 :解決済みのPrimiseは、既に解決しているため時間を待つことは無い。

## f8

予想 : 1秒後にX、Aが表示される。
回答 : 同上
説明 :`.then(errX)`で例外が発生するため、`.then(errY)`は呼び出されない。

## f9

予想 : 1秒後にY,Aが表示される。
回答 : 同上
説明 :`.then(errY)`で例外が発生し、`.catch((e) => log(e.message))`で処理される。そのあとfinallyが実行される。

## f10

予想 : 1秒後にY,Aが表示される。
説明＆回答 : 1秒後wait1()が解決され42を返す。そのあとerrYが実行されて例外を投げる。(then(r, c)はひとつ前の.thenが失敗ならcが実行される。)そして、finally内が実行されAを出力してプログラムがエラーで落ちる。

## f11

予想 : Xが出力される。
回答 : 同上
説明 :new Promise 内の throw は自動的にrejectに変換される。そのため .catch でキャッチされる。

## f12

予想 : Promiseチェーン外でエラーXが実行されるので、プログラムが落ちる。
回答 : 同上
説明 :new Promise内でsetTimeoutが実行され、0秒後にコールバック関数としてerrXが実行される。これは、普通の例外を投げるだけなのでプログラムが落ちる。
