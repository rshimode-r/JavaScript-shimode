{"version":3,"file":"main.js","mappings":"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","sources":["webpack:///./renderGrid.js","webpack:///./index.js","webpack:///./updateGrid.js"],"sourcesContent":["// grid を canvas に描画する\nexport function renderGrid(grid, ctx, ROWS, COLS, RESOLUTION) {\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLS; col++) {\n      const cell = grid[row][col];\n      ctx.beginPath();\n      ctx.rect(col * RESOLUTION, row * RESOLUTION, RESOLUTION, RESOLUTION);\n      ctx.fillStyle = cell ? 'black' : 'white';\n      ctx.fill();\n      ctx.stroke();\n    }\n  }\n}\n","import { renderGrid } from './renderGrid.js';\nimport { updateGrid } from './updateGrid.js';\n\n// 50 x 50 の盤面とする\nconst ROWS = 50;\nconst COLS = 50;\n// 1セルのサイズ\nconst RESOLUTION = 10;\n\nconst canvas = document.querySelector('#screen');\nconst ctx = canvas.getContext('2d');\nconst startButton = document.querySelector('#start');\nconst pauseButton = document.querySelector('#pause');\n\ncanvas.width = ROWS * RESOLUTION;\ncanvas.height = COLS * RESOLUTION;\n\n// https://developer.mozilla.org/ja/docs/Web/API/Window/requestAnimationFrame が返す ID\nlet animationId = null;\n\n// NOTE: download from https://soundeffect-lab.info/sound/button/mp3/decision1.mp3\nconst sound = new Audio('decision1.mp3');\n\n// ライフゲームのセル (true or false) をランダムに初期化する\nlet grid = new Array(ROWS)\n  .fill(null)\n  .map(() =>\n    new Array(COLS).fill(null).map(() => !!Math.floor(Math.random() * 2)),\n  );\n\n// canvas がクリックされたときの処理 (セルの値を反転する)\ncanvas.addEventListener('click', function (evt) {\n  const rect = canvas.getBoundingClientRect();\n  const pos = { x: evt.clientX - rect.left, y: evt.clientY - rect.top };\n\n  const row = Math.floor(pos.y / RESOLUTION);\n  const col = Math.floor(pos.x / RESOLUTION);\n  grid[row][col] = !grid[row][col];\n  sound.cloneNode().play();\n  renderGrid(grid, ctx, ROWS, COLS, RESOLUTION);\n});\n\n// requestAnimationFrame によって一定間隔で更新・描画を行う\n// TODO: リフレッシュレートの高い画面では速く実行されてしまうため、以下を参考に更新頻度が常に一定となるようにしなさい\n// https://developer.mozilla.org/ja/docs/Web/API/Window/requestAnimationFrame\n\nlet last = 0;\nconst interval = 100; //間隔→0.1s\nfunction update(t) {\n  if (t - last > interval) {\n    last = t;\n    grid = updateGrid(grid, ROWS, COLS);\n    renderGrid(grid, ctx, ROWS, COLS, RESOLUTION);\n  }\n  animationId = requestAnimationFrame(update);\n}\n\nstartButton.addEventListener('click', () => {\n  // 既にアニメーションが動いている場合は何もしない\n  if (animationId) {\n    return;\n  }\n  animationId = requestAnimationFrame(update);\n});\n\npauseButton.addEventListener('click', () => {\n  // アニメーションが停止している場合は何もしない\n  if (!animationId) {\n    return;\n  }\n  cancelAnimationFrame(animationId);\n  animationId = null;\n});\n\n// 研修中に福原さんが共有していたもの\n// クリックしたら盤面をグライダー銃にセットする\nconst gliderGunButton = document.querySelector('#gliderGun');\ngliderGunButton.addEventListener('click', () => {\n  const gunPattern = [\n    [1, 5],\n    [1, 6],\n    [2, 5],\n    [2, 6],\n    [11, 5],\n    [11, 6],\n    [11, 7],\n    [12, 4],\n    [12, 8],\n    [13, 3],\n    [14, 3],\n    [15, 6],\n    [16, 4],\n    [17, 5],\n    [17, 6],\n    [17, 7],\n    [18, 6],\n    [16, 8],\n    [13, 9],\n    [14, 9],\n    [21, 3],\n    [22, 3],\n    [21, 4],\n    [22, 4],\n    [21, 5],\n    [22, 5],\n    [23, 2],\n    [23, 6],\n    [25, 1],\n    [25, 2],\n    [25, 6],\n    [25, 7],\n    [35, 3],\n    [36, 3],\n    [35, 4],\n    [36, 4],\n  ];\n\n  // グリッドを全て白紙にする\n  const newGrid = new Array(ROWS)\n    .fill(null)\n    .map(() => new Array(COLS).fill(false));\n\n  // グライダー銃のパターンをセットする\n  gunPattern.forEach(([col, row]) => {\n    newGrid[col][row] = true; // 軸取り間違えた\n  });\n\n  grid = newGrid;\n  renderGrid(grid, ctx, ROWS, COLS, RESOLUTION);\n});\n\nrenderGrid(grid, ctx, ROWS, COLS, RESOLUTION);\n","// Life Game のルールに従ってセルを更新する\nexport function updateGrid(grid, ROWS, COLS) {\n  // 新しいグリッドを作成\n  const nextGrid = grid.map((arr) => [...arr]);\n\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLS; col++) {\n      // 周囲のセルの生存数を数えて nextGrid[row][col] に true or false を設定する (実装してね)\n\n      let liveCount = 0;\n      for (let dy = -1; dy <= 1; dy++) {\n        for (let dx = -1; dx <= 1; dx++) {\n          if (dx === 0 && dy === 0) continue; // 対象自身の時はskip\n\n          const ny = row + dy;\n          const nx = col + dx;\n\n          if (ny < 0 || ny >= ROWS || nx < 0 || nx >= COLS) continue; // 盤面の外はskip\n\n          if (grid[ny][nx]) {\n            liveCount++;\n          }\n        }\n      }\n\n      if (grid[row][col]) {\n        // 2 つまたは 3 つの生きている隣接細胞を持つ生きている細胞は、次の世代に生き続けます。\n        nextGrid[row][col] = liveCount === 2 || liveCount === 3;\n      } else {\n        // ちょうど 3 つの生きている隣接細胞を持つ死んだ細胞は、再生したかのように生きた細胞になります。\n        nextGrid[row][col] = liveCount === 3;\n      }\n    }\n  }\n  return nextGrid;\n}\n"],"names":["renderGrid","grid","ctx","ROWS","COLS","RESOLUTION","row","col","cell","beginPath","rect","fillStyle","fill","stroke","canvas","document","querySelector","getContext","startButton","pauseButton","width","height","animationId","sound","Audio","Array","map","Math","floor","random","addEventListener","evt","getBoundingClientRect","pos","clientX","left","clientY","top","cloneNode","play","last","update","t","nextGrid","arr","liveCount","dy","dx","ny","nx","updateGrid","requestAnimationFrame","cancelAnimationFrame","newGrid","forEach"],"sourceRoot":""}